{"version":3,"file":"metadata-field.js","sourceRoot":"","sources":["../../../../src/models/metadata-fields/metadata-field.ts"],"names":[],"mappings":"AAOA;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,OAAO,aAAa;IAkCxB,YAAY,MAAgC,EAAE,QAA2B;QAtBzE;;;;;;;;WAQG;QACH,WAAM,GAAW,EAAE,CAAC;QAclB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAEzB,IAAI,CAAC,eAAe,EAAE,CAAC;IACzB,CAAC;IAhBD;;;;;;OAMG;IACH,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAC7D,CAAC;IAWO,eAAe;QACrB,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;YAC/B,OAAO;SACR;QAED,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAChC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBAC5B,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;YACnC,CAAC,CAAC,CAAC;SACJ;aAAM;YACL,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC1C;IACH,CAAC;IAEO,oBAAoB,CAAC,KAA0B;QACrD,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAClD,IAAI,WAAW,KAAK,SAAS,EAAE;YAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAC/B;IACH,CAAC;CACF","sourcesContent":["import {\n  FieldParserInterface,\n  FieldParserRawValue,\n} from '@internetarchive/field-parsers';\n\nexport type MetadataRawValue = string | string[] | number | boolean;\n\n/**\n * The MetadataField is responsible for three things:\n * 1. Take in some raw data (strings, arrays, numbers, etc)\n * 2. Normalize the input to an array of the input,\n *    ie. [string, string], [number, number], [Date, Date], etc\n * 3. Cast the values to their expected `Type`\n *\n * This class gets instiated with a `Type` and a parser of that type. For instance, the\n * `DateField` is a subclass of `MetadataField` with a `Type` of `Date` and a `DateParser`.\n *\n * When using a `DateField`, you can pass it a string date and it will cast it to a javascript Date,\n * ie:\n *\n * ```\n * const dateField = new DateField('2020-02-13')\n * dateField.value = Date(2020-02-13) // native javascript Date object\n * dateField.values = [Date(2020-02-13)] // the normalized array of values\n * dateField.rawValue = '2020-02-13' // the raw string that was passed in\n * ```\n *\n * @class MetadataField\n * @template Type The type of metadata this is (string, number, Date, etc)\n * @template FieldParserInterfaceType The parser for that type (StringParser, NumberParser, etc)\n */\nexport class MetadataField<\n  Type,\n  FieldParserInterfaceType extends FieldParserInterface<Type>\n> {\n  /**\n   * The raw value received from the API response\n   *\n   * @type {MetadataRawValue}\n   * @memberof MetadataField\n   */\n  rawValue?: MetadataRawValue;\n\n  /**\n   * The array of all values for the field.\n   *\n   * Many fields only contain a single value and\n   * can be accessed via the `.value` getter\n   *\n   * @type {Type[]}\n   * @memberof MetadataField\n   */\n  values: Type[] = [];\n\n  /**\n   * The first value if there are multiple or the only value if there is one\n   *\n   * @readonly\n   * @type {(Type | undefined)}\n   * @memberof MetadataField\n   */\n  get value(): Type | undefined {\n    return this.values.length > 0 ? this.values[0] : undefined;\n  }\n\n  constructor(parser: FieldParserInterfaceType, rawValue?: MetadataRawValue) {\n    this.parser = parser;\n    this.rawValue = rawValue;\n\n    this.processRawValue();\n  }\n\n  private parser: FieldParserInterfaceType;\n\n  private processRawValue(): void {\n    if (this.rawValue === undefined) {\n      return;\n    }\n\n    if (Array.isArray(this.rawValue)) {\n      this.rawValue.forEach(value => {\n        this.parseAndPersistValue(value);\n      });\n    } else {\n      this.parseAndPersistValue(this.rawValue);\n    }\n  }\n\n  private parseAndPersistValue(value: FieldParserRawValue): void {\n    const parsedValue = this.parser.parseValue(value);\n    if (parsedValue !== undefined) {\n      this.values.push(parsedValue);\n    }\n  }\n}\n"]}