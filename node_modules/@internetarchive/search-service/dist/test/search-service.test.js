/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { expect } from '@open-wc/testing';
import { SearchService } from '../src/search-service';
import { SearchParams } from '../src/search-params';
import { MockResponseGenerator } from './mock-response-generator';
import { SearchServiceError, SearchServiceErrorType, } from '../src/search-service-error';
describe('SearchService', () => {
    it('can search when requested', async () => {
        var _a;
        class MockSearchBackend {
            async fetchMetadata(identifier) {
                throw new Error('Method not implemented.');
            }
            async performSearch(params) {
                const responseGenerator = new MockResponseGenerator();
                const mockResponse = responseGenerator.generateMockSearchResponse(params);
                return { success: mockResponse };
            }
        }
        const query = 'title:foo AND collection:bar';
        const params = new SearchParams({ query });
        const backend = new MockSearchBackend();
        const service = new SearchService(backend);
        const result = await service.search(params);
        expect((_a = result.success) === null || _a === void 0 ? void 0 : _a.responseHeader.params.query).to.equal(query);
    });
    it('can request metadata when requested', async () => {
        var _a;
        class MockSearchBackend {
            performSearch(params) {
                throw new Error('Method not implemented.');
            }
            async fetchMetadata(identifier) {
                const responseGenerator = new MockResponseGenerator();
                const mockResponse = responseGenerator.generateMockMetadataResponse(identifier);
                return { success: mockResponse };
            }
        }
        const backend = new MockSearchBackend();
        const service = new SearchService(backend);
        const result = await service.fetchMetadata('foo');
        expect((_a = result.success) === null || _a === void 0 ? void 0 : _a.metadata.identifier).to.equal('foo');
    });
    it('returns an error result if the item is not found', async () => {
        var _a;
        class MockSearchBackend {
            performSearch(params) {
                throw new Error('Method not implemented.');
            }
            async fetchMetadata(identifier) {
                // this is unfortunate.. instead of getting an http 404 error,
                // we get an empty JSON object when an item is not found
                return { success: {} };
            }
        }
        const backend = new MockSearchBackend();
        const service = new SearchService(backend);
        const result = await service.fetchMetadata('foo');
        expect(result.error).to.not.equal(undefined);
        expect((_a = result.error) === null || _a === void 0 ? void 0 : _a.type).to.equal(SearchServiceErrorType.itemNotFound);
    });
    it('returns the search backend network error if one occurs', async () => {
        var _a, _b, _c, _d;
        class MockSearchBackend {
            async performSearch(params) {
                const error = new SearchServiceError(SearchServiceErrorType.networkError, 'network error');
                return { error };
            }
            async fetchMetadata(identifier) {
                const error = new SearchServiceError(SearchServiceErrorType.networkError, 'network error');
                return { error };
            }
        }
        const backend = new MockSearchBackend();
        const service = new SearchService(backend);
        const metadataResult = await service.fetchMetadata('foo');
        expect(metadataResult.error).to.not.equal(undefined);
        expect((_a = metadataResult.error) === null || _a === void 0 ? void 0 : _a.type).to.equal(SearchServiceErrorType.networkError);
        expect((_b = metadataResult.error) === null || _b === void 0 ? void 0 : _b.message).to.equal('network error');
        const params = new SearchParams({ query: 'boop' });
        const searchResult = await service.search(params);
        expect(searchResult.error).to.not.equal(undefined);
        expect((_c = searchResult.error) === null || _c === void 0 ? void 0 : _c.type).to.equal(SearchServiceErrorType.networkError);
        expect((_d = searchResult.error) === null || _d === void 0 ? void 0 : _d.message).to.equal('network error');
    });
    it('returns the search backend decoding error if one occurs', async () => {
        var _a, _b, _c, _d;
        class MockSearchBackend {
            async performSearch(params) {
                const error = new SearchServiceError(SearchServiceErrorType.decodingError, 'decoding error');
                return { error };
            }
            async fetchMetadata(identifier) {
                const error = new SearchServiceError(SearchServiceErrorType.decodingError, 'decoding error');
                return { error };
            }
        }
        const backend = new MockSearchBackend();
        const service = new SearchService(backend);
        const metadataResult = await service.fetchMetadata('foo');
        expect(metadataResult.error).to.not.equal(undefined);
        expect((_a = metadataResult.error) === null || _a === void 0 ? void 0 : _a.type).to.equal(SearchServiceErrorType.decodingError);
        expect((_b = metadataResult.error) === null || _b === void 0 ? void 0 : _b.message).to.equal('decoding error');
        const params = new SearchParams({ query: 'boop' });
        const searchResult = await service.search(params);
        expect(searchResult.error).to.not.equal(undefined);
        expect((_c = searchResult.error) === null || _c === void 0 ? void 0 : _c.type).to.equal(SearchServiceErrorType.decodingError);
        expect((_d = searchResult.error) === null || _d === void 0 ? void 0 : _d.message).to.equal('decoding error');
    });
});
//# sourceMappingURL=search-service.test.js.map