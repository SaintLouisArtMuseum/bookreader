/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { expect } from '@open-wc/testing';
import { SearchParams } from '../src/search-params';
import { SearchServiceErrorType } from '../src/search-service-error';
import { DefaultSearchBackend } from '../src/search-backend/default-search-backend';
describe('DefaultSearchBackend', () => {
    it('can fetch metadata', async () => {
        var _a;
        const fetchBackup = window.fetch;
        window.fetch = () => {
            return new Promise(resolve => {
                const response = new Response('{ "foo": "bar" }');
                resolve(response);
            });
        };
        const backend = new DefaultSearchBackend();
        const result = await backend.fetchMetadata('foo');
        expect((_a = result.success) === null || _a === void 0 ? void 0 : _a.foo).to.equal('bar');
        window.fetch = fetchBackup;
    });
    it('can perform a search', async () => {
        var _a;
        const fetchBackup = window.fetch;
        window.fetch = () => {
            return new Promise(resolve => {
                const response = new Response('{ "foo": "bar" }');
                resolve(response);
            });
        };
        const backend = new DefaultSearchBackend();
        const params = new SearchParams({ query: 'foo' });
        const result = await backend.performSearch(params);
        expect((_a = result.success) === null || _a === void 0 ? void 0 : _a.foo).to.equal('bar');
        window.fetch = fetchBackup;
    });
    it('returns a networkError if theres a problem fetching using String type', async () => {
        var _a, _b;
        const fetchBackup = window.fetch;
        window.fetch = () => {
            throw 'network error';
        };
        const backend = new DefaultSearchBackend();
        const result = await backend.fetchMetadata('foo');
        expect((_a = result.error) === null || _a === void 0 ? void 0 : _a.type).to.equal(SearchServiceErrorType.networkError);
        expect((_b = result.error) === null || _b === void 0 ? void 0 : _b.message).to.equal('network error');
        window.fetch = fetchBackup;
    });
    it('returns a networkError if theres a problem fetching using Error type', async () => {
        var _a, _b;
        const fetchBackup = window.fetch;
        window.fetch = () => {
            throw new Error('network error');
        };
        const backend = new DefaultSearchBackend();
        const result = await backend.fetchMetadata('foo');
        expect((_a = result.error) === null || _a === void 0 ? void 0 : _a.type).to.equal(SearchServiceErrorType.networkError);
        expect((_b = result.error) === null || _b === void 0 ? void 0 : _b.message).to.equal('network error');
        window.fetch = fetchBackup;
    });
    it('returns a decodingError if theres a problem decoding the json', async () => {
        var _a;
        const fetchBackup = window.fetch;
        window.fetch = () => {
            const response = new Response('boop');
            return new Promise(resolve => resolve(response));
        };
        const backend = new DefaultSearchBackend();
        const result = await backend.fetchMetadata('foo');
        expect((_a = result.error) === null || _a === void 0 ? void 0 : _a.type).to.equal(SearchServiceErrorType.decodingError);
        window.fetch = fetchBackup;
    });
});
//# sourceMappingURL=default-search-backend.test.js.map