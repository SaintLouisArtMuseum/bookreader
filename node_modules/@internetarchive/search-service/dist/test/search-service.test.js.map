{"version":3,"file":"search-service.test.js","sourceRoot":"","sources":["../../test/search-service.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { expect } from '@open-wc/testing';\n\nimport { SearchService } from '../src/search-service';\nimport { SearchParams } from '../src/search-params';\n\nimport { MockResponseGenerator } from './mock-response-generator';\nimport { SearchResponse } from '../src/responses/search/search-response';\nimport { MetadataResponse } from '../src/responses/metadata/metadata-response';\nimport { Result } from '@internetarchive/result-type';\nimport {\n  SearchServiceError,\n  SearchServiceErrorType,\n} from '../src/search-service-error';\nimport { SearchBackendInterface } from '../src/search-backend/search-backend-interface';\n\ndescribe('SearchService', () => {\n  it('can search when requested', async () => {\n    class MockSearchBackend implements SearchBackendInterface {\n      async fetchMetadata(\n        identifier: string\n      ): Promise<Result<MetadataResponse, SearchServiceError>> {\n        throw new Error('Method not implemented.');\n      }\n\n      async performSearch(\n        params: SearchParams\n      ): Promise<Result<SearchResponse, SearchServiceError>> {\n        const responseGenerator = new MockResponseGenerator();\n        const mockResponse = responseGenerator.generateMockSearchResponse(\n          params\n        );\n        return { success: mockResponse };\n      }\n    }\n\n    const query = 'title:foo AND collection:bar';\n    const params = new SearchParams({ query });\n    const backend = new MockSearchBackend();\n    const service = new SearchService(backend);\n    const result = await service.search(params);\n    expect(result.success?.responseHeader.params.query).to.equal(query);\n  });\n\n  it('can request metadata when requested', async () => {\n    class MockSearchBackend implements SearchBackendInterface {\n      performSearch(\n        params: SearchParams\n      ): Promise<Result<SearchResponse, SearchServiceError>> {\n        throw new Error('Method not implemented.');\n      }\n      async fetchMetadata(\n        identifier: string\n      ): Promise<Result<MetadataResponse, SearchServiceError>> {\n        const responseGenerator = new MockResponseGenerator();\n        const mockResponse = responseGenerator.generateMockMetadataResponse(\n          identifier\n        );\n        return { success: mockResponse };\n      }\n    }\n\n    const backend = new MockSearchBackend();\n    const service = new SearchService(backend);\n    const result = await service.fetchMetadata('foo');\n    expect(result.success?.metadata.identifier).to.equal('foo');\n  });\n\n  it('returns an error result if the item is not found', async () => {\n    class MockSearchBackend implements SearchBackendInterface {\n      performSearch(\n        params: SearchParams\n      ): Promise<Result<SearchResponse, SearchServiceError>> {\n        throw new Error('Method not implemented.');\n      }\n      async fetchMetadata(\n        identifier: string\n      ): Promise<Result<MetadataResponse, SearchServiceError>> {\n        // this is unfortunate.. instead of getting an http 404 error,\n        // we get an empty JSON object when an item is not found\n        return { success: {} as any };\n      }\n    }\n\n    const backend = new MockSearchBackend();\n    const service = new SearchService(backend);\n    const result = await service.fetchMetadata('foo');\n    expect(result.error).to.not.equal(undefined);\n    expect(result.error?.type).to.equal(SearchServiceErrorType.itemNotFound);\n  });\n\n  it('returns the search backend network error if one occurs', async () => {\n    class MockSearchBackend implements SearchBackendInterface {\n      async performSearch(\n        params: SearchParams\n      ): Promise<Result<SearchResponse, SearchServiceError>> {\n        const error = new SearchServiceError(\n          SearchServiceErrorType.networkError,\n          'network error'\n        );\n        return { error };\n      }\n      async fetchMetadata(\n        identifier: string\n      ): Promise<Result<MetadataResponse, SearchServiceError>> {\n        const error = new SearchServiceError(\n          SearchServiceErrorType.networkError,\n          'network error'\n        );\n        return { error };\n      }\n    }\n\n    const backend = new MockSearchBackend();\n    const service = new SearchService(backend);\n    const metadataResult = await service.fetchMetadata('foo');\n    expect(metadataResult.error).to.not.equal(undefined);\n    expect(metadataResult.error?.type).to.equal(\n      SearchServiceErrorType.networkError\n    );\n    expect(metadataResult.error?.message).to.equal('network error');\n\n    const params = new SearchParams({ query: 'boop' });\n    const searchResult = await service.search(params);\n    expect(searchResult.error).to.not.equal(undefined);\n    expect(searchResult.error?.type).to.equal(\n      SearchServiceErrorType.networkError\n    );\n    expect(searchResult.error?.message).to.equal('network error');\n  });\n\n  it('returns the search backend decoding error if one occurs', async () => {\n    class MockSearchBackend implements SearchBackendInterface {\n      async performSearch(\n        params: SearchParams\n      ): Promise<Result<SearchResponse, SearchServiceError>> {\n        const error = new SearchServiceError(\n          SearchServiceErrorType.decodingError,\n          'decoding error'\n        );\n        return { error };\n      }\n      async fetchMetadata(\n        identifier: string\n      ): Promise<Result<MetadataResponse, SearchServiceError>> {\n        const error = new SearchServiceError(\n          SearchServiceErrorType.decodingError,\n          'decoding error'\n        );\n        return { error };\n      }\n    }\n\n    const backend = new MockSearchBackend();\n    const service = new SearchService(backend);\n    const metadataResult = await service.fetchMetadata('foo');\n    expect(metadataResult.error).to.not.equal(undefined);\n    expect(metadataResult.error?.type).to.equal(\n      SearchServiceErrorType.decodingError\n    );\n    expect(metadataResult.error?.message).to.equal('decoding error');\n\n    const params = new SearchParams({ query: 'boop' });\n    const searchResult = await service.search(params);\n    expect(searchResult.error).to.not.equal(undefined);\n    expect(searchResult.error?.type).to.equal(\n      SearchServiceErrorType.decodingError\n    );\n    expect(searchResult.error?.message).to.equal('decoding error');\n  });\n});\n"]}