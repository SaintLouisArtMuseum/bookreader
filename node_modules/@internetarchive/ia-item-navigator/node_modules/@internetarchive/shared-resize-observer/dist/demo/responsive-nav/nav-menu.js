import { __decorate } from "tslib";
import { css, customElement, html, LitElement, property, queryAll, } from 'lit-element';
import { ResponsiveNavMenuMode } from './models/menu-mode';
let ResponsiveNavMenu = class ResponsiveNavMenu extends LitElement {
    constructor() {
        super(...arguments);
        this.menuOptions = [];
        this.itemMode = ResponsiveNavMenuMode.IconText;
        this.navItemSpacing = 10;
    }
    updated(changed) {
        if (changed.has('navItemSpacing')) {
            // this keeps our JS and CSS in sync so the JS can calculate the width
            // for changing modes and the CSS spaces properly
            this.style.setProperty('--responsive-nav-item-spacing', `${this.navItemSpacing}px`);
        }
    }
    render() {
        return html `
      <ul>
        ${this.menuOptions.map(option => html `
            <li>
              <responsive-nav-item
                .mode=${this.itemMode}
                .icon=${option.icon}
                .text=${option.title}
              >
              </responsive-nav-item>
            </li>
          `)}
      </ul>
    `;
    }
    // the estimated full width
    get estimateFullWidth() {
        let estimatedWidth = 0;
        this.navItems.forEach(item => {
            estimatedWidth += item.estimatedFullWidth + this.navItemSpacing + 2;
        });
        estimatedWidth -= this.navItemSpacing;
        return estimatedWidth;
    }
    // the estimated icon-only width
    get estimateIconOnlyWidth() {
        const totalMenuItems = this.navItems.length;
        return ((this.navItems[0].estimatedIconOnlyWidth + this.navItemSpacing + 2) *
            totalMenuItems -
            this.navItemSpacing);
    }
    static get styles() {
        const navItemSpacing = css `var(--responsive-nav-item-spacing, 10px)`;
        return css `
      :host {
        display: inline-block;
      }

      ul {
        display: inline-block;
        margin: 0;
        padding: 0;
      }

      li {
        display: inline-block;
        margin-right: ${navItemSpacing};
        padding: 0;
      }

      li:last-child {
        margin-right: 0;
      }
    `;
    }
};
__decorate([
    property({ type: Array })
], ResponsiveNavMenu.prototype, "menuOptions", void 0);
__decorate([
    property({ type: String })
], ResponsiveNavMenu.prototype, "itemMode", void 0);
__decorate([
    queryAll('responsive-nav-item')
], ResponsiveNavMenu.prototype, "navItems", void 0);
__decorate([
    property({ type: Number })
], ResponsiveNavMenu.prototype, "navItemSpacing", void 0);
ResponsiveNavMenu = __decorate([
    customElement('responsive-nav-menu')
], ResponsiveNavMenu);
export { ResponsiveNavMenu };
//# sourceMappingURL=nav-menu.js.map