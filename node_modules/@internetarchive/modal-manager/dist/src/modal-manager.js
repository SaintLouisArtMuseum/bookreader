import { __awaiter, __decorate } from "tslib";
import { LitElement, html, css, } from 'lit';
import { property, customElement, query } from 'lit/decorators.js';
import './modal-template';
import { ModalManagerHostBridge } from './modal-manager-host-bridge';
import { ModalManagerMode } from './modal-manager-mode';
let ModalManager = class ModalManager extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * The current mode of the ModalManager
         *
         * Current options are `modal` or `closed`
         *
         * @type {ModalManagerMode}
         * @memberof ModalManager
         */
        this.mode = ModalManagerMode.Closed;
        /**
         * Thie hostBridge handles environmental-specific interactions such as adding classes
         * to the body tag or event listeners needed to support the modal manager in the host environment.
         *
         * There is a default `ModalManagerHostBridge`, but consumers can override it with a custom
         * `ModalManagerHostBridgeInterface`
         *
         * @type {ModalManagerHostBridgeInterface}
         * @memberof ModalManager
         */
        this.hostBridge = new ModalManagerHostBridge(this);
        /**
         * Whether the modal should close if the user taps on the backdrop
         *
         * @private
         * @memberof ModalManager
         */
        this.closeOnBackdropClick = true;
    }
    /** @inheritdoc */
    render() {
        return html `
      <div class="container">
        <div class="backdrop" @click=${this.backdropClicked}></div>
        <modal-template
          @closeButtonPressed=${this.closeButtonPressed}
          tabindex="0"
        >
          ${this.customModalContent}
        </modal-template>
      </div>
    `;
    }
    /** @inheritdoc */
    getMode() {
        return this.mode;
    }
    /** @inheritdoc */
    closeModal() {
        this.mode = ModalManagerMode.Closed;
    }
    /**
     * Call the userClosedModalCallback and reset it if it exists
     *
     * @private
     * @memberof ModalManager
     */
    callUserClosedModalCallback() {
        // we assign the callback to a temp var and undefine it before calling it
        // otherwise, we run into the potential for an infinite loop if the
        // callback triggers another `showModal()`, which would execute `userClosedModalCallback`
        const callback = this.userClosedModalCallback;
        this.userClosedModalCallback = undefined;
        if (callback)
            callback();
    }
    /** @inheritdoc */
    showModal(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.closeOnBackdropClick = options.config.closeOnBackdropClick;
            this.userClosedModalCallback = options.userClosedModalCallback;
            this.modalTemplate.config = options.config;
            this.customModalContent = options.customModalContent;
            this.mode = ModalManagerMode.Open;
            yield this.modalTemplate.updateComplete;
            this.modalTemplate.focus();
        });
    }
    /** @inheritdoc */
    updated(changed) {
        /* istanbul ignore else */
        if (changed.has('mode')) {
            this.handleModeChange();
        }
    }
    /**
     * Called when the backdrop is clicked
     *
     * @private
     * @memberof ModalManager
     */
    backdropClicked() {
        if (this.closeOnBackdropClick) {
            this.closeModal();
            this.callUserClosedModalCallback();
        }
    }
    /**
     * Handle the mode change
     *
     * @private
     * @memberof ModalManager
     */
    handleModeChange() {
        this.hostBridge.handleModeChange(this.mode);
        this.emitModeChangeEvent();
    }
    /**
     * Emit a modeChange event
     *
     * @private
     * @memberof ModalManager
     */
    emitModeChangeEvent() {
        const event = new CustomEvent('modeChanged', {
            detail: { mode: this.mode },
        });
        this.dispatchEvent(event);
    }
    /**
     * Called when the modal close button is pressed. Closes the modal.
     *
     * @private
     * @memberof ModalManager
     */
    closeButtonPressed() {
        this.closeModal();
        this.callUserClosedModalCallback();
    }
    /** @inheritdoc */
    static get styles() {
        const modalBackdropColor = css `var(--modalBackdropColor, rgba(10, 10, 10, 0.9))`;
        const modalBackdropZindex = css `var(--modalBackdropZindex, 1000)`;
        const modalWidth = css `var(--modalWidth, 32rem)`;
        const modalMaxWidth = css `var(--modalMaxWidth, 95%)`;
        const modalZindex = css `var(--modalZindex, 2000)`;
        return css `
      .container {
        width: 100%;
        height: 100%;
      }

      .backdrop {
        position: fixed;
        top: 0;
        left: 0;
        background-color: ${modalBackdropColor};
        width: 100%;
        height: 100%;
        z-index: ${modalBackdropZindex};
      }

      modal-template {
        outline: 0;
        position: fixed;
        top: 0;
        left: 50%;
        transform: translate(-50%, 0);
        z-index: ${modalZindex};
        width: ${modalWidth};
        max-width: ${modalMaxWidth};
      }
    `;
    }
};
__decorate([
    property({ type: String, reflect: true })
], ModalManager.prototype, "mode", void 0);
__decorate([
    property({ type: Object })
], ModalManager.prototype, "customModalContent", void 0);
__decorate([
    property({ type: Object })
], ModalManager.prototype, "hostBridge", void 0);
__decorate([
    query('modal-template')
], ModalManager.prototype, "modalTemplate", void 0);
ModalManager = __decorate([
    customElement('modal-manager')
], ModalManager);
export { ModalManager };
//# sourceMappingURL=modal-manager.js.map