{"version":3,"file":"duration.js","sourceRoot":"","sources":["../../../src/field-types/duration.ts"],"names":[],"mappings":"AAUA;;;;GAIG;AACH,MAAM,OAAO,cAAc;IAKzB,kBAAkB;IAClB,UAAU,CAAC,QAA6B;QACtC,IAAI,OAAO,QAAQ,KAAK,QAAQ;YAAE,OAAO,QAAQ,CAAC;QAClD,IAAI,OAAO,QAAQ,KAAK,SAAS;YAAE,OAAO,SAAS,CAAC;QAEpD,MAAM,cAAc,GAAa,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACrD,IAAI,OAA2B,CAAC;QAChC,6FAA6F;QAC7F,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;SACrD;aAAM;YACL,OAAO,GAAG,IAAI,CAAC,yBAAyB,CAAC,cAAc,CAAC,CAAC;SAC1D;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;;OAKG;IACK,iBAAiB,CAAC,QAAgB;QACxC,IAAI,OAAO,GAAuB,UAAU,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;YAAE,OAAO,GAAG,SAAS,CAAC;QAC/C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;;OAKG;IACK,yBAAyB,CAC/B,cAAwB;QAExB,mEAAmE;QACnE,IAAI,eAAe,GAAG,KAAK,CAAC;QAC5B,MAAM,WAAW,GAAG,cAAc;aAC/B,GAAG,CAAC,CAAC,OAAe,EAAE,KAAa,EAAE,EAAE;YACtC,MAAM,cAAc,GAAW,UAAU,CAAC,OAAO,CAAC,CAAC;YACnD,IAAI,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;gBAChC,eAAe,GAAG,IAAI,CAAC;gBACvB,OAAO,CAAC,CAAC;aACV;YACD,MAAM,QAAQ,GAAW,cAAc,CAAC,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC;YAC3D,MAAM,UAAU,GAAW,EAAE,IAAI,QAAQ,CAAC;YAC1C,OAAO,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QACjD,CAAC,CAAC;aACD,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QAE9B,OAAO,eAAe,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW,CAAC;IACnD,CAAC;;AA1DD,0DAA0D;AAC1D,6CAA6C;AACtC,qBAAM,GAAG,IAAI,cAAc,EAAE,CAAC","sourcesContent":["import {\n  FieldParserInterface,\n  FieldParserRawValue,\n} from '../field-parser-interface';\n\n/**\n * Duration is a number in seconds\n */\nexport type Duration = number;\n\n/**\n * Parses duration format to a `Duration` (number of seconds with decimal)\n *\n * Can parse hh:mm:ss.ms, hh:mm:ss, mm:ss, mm:ss.ms, and s.ms formats\n */\nexport class DurationParser implements FieldParserInterface<Duration> {\n  // use a shared static instance for performance instead of\n  // instantiating a new instance for every use\n  static shared = new DurationParser();\n\n  /** @inheritdoc */\n  parseValue(rawValue: FieldParserRawValue): Duration | undefined {\n    if (typeof rawValue === 'number') return rawValue;\n    if (typeof rawValue === 'boolean') return undefined;\n\n    const componentArray: string[] = rawValue.split(':');\n    let seconds: number | undefined;\n    // if there are no colons in the string, we can assume it's in sss.ms format so just parse it\n    if (componentArray.length === 1) {\n      seconds = this.parseNumberFormat(componentArray[0]);\n    } else {\n      seconds = this.parseColonSeparatedFormat(componentArray);\n    }\n\n    return seconds;\n  }\n\n  /**\n   * Parse sss.ms format\n   *\n   * @param rawValue\n   * @returns\n   */\n  private parseNumberFormat(rawValue: string): number | undefined {\n    let seconds: number | undefined = parseFloat(rawValue);\n    if (Number.isNaN(seconds)) seconds = undefined;\n    return seconds;\n  }\n\n  /**\n   * Parse hh:mm:ss.ms format\n   *\n   * @param componentArray\n   * @returns\n   */\n  private parseColonSeparatedFormat(\n    componentArray: string[]\n  ): number | undefined {\n    // if any of the hh:mm:ss components are NaN, just return undefined\n    let hasNaNComponent = false;\n    const parsedValue = componentArray\n      .map((element: string, index: number) => {\n        const componentValue: number = parseFloat(element);\n        if (Number.isNaN(componentValue)) {\n          hasNaNComponent = true;\n          return 0;\n        }\n        const exponent: number = componentArray.length - 1 - index;\n        const multiplier: number = 60 ** exponent;\n        return componentValue * Math.floor(multiplier);\n      })\n      .reduce((a, b) => a + b, 0);\n\n    return hasNaNComponent ? undefined : parsedValue;\n  }\n}\n"]}